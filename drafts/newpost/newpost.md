初学者也能懂的避免 .NET 性能问题的技巧

我原本想为这篇博客取名为“初学者也能懂的编写高性能 .NET 代码的技巧”，思考后又觉得 **“高性能”** 容易误导一些大佬以为发现宝藏点进来，却看到一些人尽皆知的套路，大失所望然后把我批判一番，遂改为当前的标题。

我当然不可能把所有技巧都总结全，只能总结我遇到过，且我暂时能记得起来的技巧。.NET 虽然上手极其容易，但想写好也很困难，是需要你在写代码的过程中时刻思考，时刻查询，时刻提问。学而不思则罔。希望广大 .NET 新人开发者不要成为“一年经验用十年”的码农🐸

一毛不拔的性能优化常常破坏代码抽象、可读性和可维护性。在学习了性能知识后，很容易沉溺其中，眼里只有性能，患上“性能洁癖”。为了不重要的性能优化而破坏代码可维护性和可读性是因小失大，请避免。

## 请首先“测量”！

您可以参照本篇博客提到的避免性能问题的技巧来编写没有性能问题的代码，但如果您尝试优化现有的代码仓库，或者对比多种代码写法的性能，这是要消耗时间和精力的，甚至可能耽误工期，您应该先进行 **“测量”**，来找出您的系统慢在哪个环节。如果您不了解如何进行测量，可以阅读我之前的系列博客：[为什么我的接口，慢得跟蜗牛一样啊？系列文章目录与导读：https://cat.aiursoft.cn/post/2023/3/14/why-is-my-web-api-so-slow](https://cat.aiursoft.cn/post/2023/3/14/why-is-my-web-api-so-slow)，该系列文章简单介绍了如何使用日志等方法测量性能。您也可以使用类似 BenchmarkDotNet 库、dotTrace、dotMemory 等工具测量性能。

```
//一个任务是可以设置多个延续任务的，任务是并行的
Task taskContinue = new Task(() =>
{
    Console.WriteLine("延续主任务开始执行");
    //Task.Delay(2000)
});

//子任务1和子任务2属于同级并行任
taskContinue.Start();
```

## 性能技巧

IEunmerable 多次迭代

可以不抛出异常的时候，尽量不要抛出异常

尽量避免强制类型转换 必须避免无效的转换。这将导致抛出 InvalidCastException 类型的异常，其开销远远超过实际转换的成本。is 操作符是一种测试结果并返回布尔值的转换。as 操作符类似于标准转换，但如果转换失败则返回 null。从上面的结果可以看出，与抛出异常相比，使用 as 操作符要快得多。


## 最优先的性能优化方式

根据我的经验，最离谱的性能问题往往发生在 C# .NET 代码以外。例如性能太差的 SQL 命令、网络问题等。如果您打算消耗时间和精力全力优化您的代码，请先考虑以下性能优化的方式：

1. 优化 SQL 语句或者使用 ORM 时写的 LINQ 语句，不要有很离谱的查询。如果有代码层面避免不了的长时间的查询，尝试调整数据库，例如加索引等操作；
2. 如果查询的数据表的数据量确实太大，考虑分库分表读写分离等操作。根据您选择的数据库，进行大数据量的实验，或者查询或咨询有经验的同行和 DBA，来判断多大的数据量对您的数据库来说算太大。
3. 使用缓存，把热点数据缓存起来。查询缓存要比查询关系型数据库要快很多。根据你的项目的情况选择内存缓存、Redis、Memcached 等；
4. 在 ASP.NET Core 项目中启用压缩，以减小通过网络发送的数据大小；
5. 通过捆绑和缓存静态资源（如 CSS 和 JavaScript 文件）来减少 HTTP 请求；
6. 使用 cdn；
7. 一些我暂时没有想到的其他方法。

当你实现了以上优化方式，再来考虑我们今天要讨论的代码层面的优化方式。

## 摒弃刻板印象

有一些刻板印象可能会给我们带来麻烦，比如：

- .NET Framework 慢得像乌龟，.NET Core/5/6/7 快得像兔子，只要把基于 .NET Framework 的项目升级到 .NET 7，一切都会好起来的。这一定程度上这是对的，但如果您的项目平稳运行，只有一点点慢，我更建议您采取简单的优化方式，而不是直接武断的升级成 .NET 7，因为重构可能带来更大的麻烦，除非您的项目结构真的很简单，可以轻松完成升级；
- dapper ORM 快得像闪电，而 EF/EF Core 的速度跟 dapper 比就是辣鸡。dapper 可能确实快，但 EF/EF Core 并不慢。在您决定重构代码来把 EF 换成 dapper 之前，请先进行测量和评估，如果在某些场景下，EF 确实有严重的性能问题，可以引入 dapper 来实现这些场景。是的，EF 和 dapper 可以共存于同一个代码库，并不需要拼个你死我活；
- 一些我暂时没有想到的其他刻板印象。

如果我没有搞错的话，